<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Elliptical Orbits with Three.js</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // Scene, Camera, and Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Orbit Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 100;

    // Adjust the camera position
    camera.position.set(0, 20, 50);
    controls.update();

    // List of planets to fetch (added Jupiter, Saturn, Uranus, and Neptune)
    const planetNames = ['mercure', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune'];
    const planetsData = {};  // Dictionary to store planet data
    const planetObjects = {}; // Dictionary to store planet meshes

    // Colors and sizes for planets (approximate scale relative to the sun)
    const scaleFactor = 10; // Adjust this factor to increase the size of the planets
    const planetProperties = {
        'mercure': { color: 0x8c7c6c, size: 0.0035 * scaleFactor },
        'venus': { color: 0xffd085, size: 0.0087 * scaleFactor },
        'earth': { color: 0x4b9bd7, size: 0.0092 * scaleFactor },
        'mars': { color: 0xd48f8a, size: 0.0049 * scaleFactor },
        'jupiter': { color: 0xc2b280, size: 0.1008 * scaleFactor }, // Jupiter properties
        'saturn': { color: 0xe2b21c, size: 0.0837 * scaleFactor },  // Saturn properties
        'uranus': { color: 0x4bc1d2, size: 0.0364 * scaleFactor },  // Uranus properties
        'neptune': { color: 0x3e3e9c, size: 0.0354 * scaleFactor }   // Neptune properties
    };

    // Create the Sun (only once)
    const sunGeometry = new THREE.SphereGeometry(0.9, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    // Scale factor for orbits
    const orbitScale = 0.01; // Reduce this value to make orbits smaller

    // Fetch data for each planet and initialize the orbit
    async function fetchOrbitalParameters(planetName) {
        const response = await fetch(`https://api.le-systeme-solaire.net/rest/bodies/${planetName}`);
        const data = await response.json();

        const params = {
            semiMajorAxis: data.semimajorAxis * orbitScale / 1e6,  // Adjusted scale
            eccentricity: data.eccentricity,
            orbitalPeriod: data.sideralOrbit, // in days
            inclination: THREE.MathUtils.degToRad(data.inclination),
            longitudeAscendingNode: THREE.MathUtils.degToRad(data.longAscNode),
            argumentOfPeriapsis: THREE.MathUtils.degToRad(data.argPeriapsis)
        };
        console.log(`${planetName} Parameters:`, params);
        planetsData[planetName] = params;
        initializeOrbit(planetName, params);
    }

    // Fetch data for all planets
    planetNames.forEach(planet => fetchOrbitalParameters(planet));

    // Function to initialize orbit with real parameters for each planet
    function initializeOrbit(planetName, params) {
        const { semiMajorAxis: a, eccentricity, inclination, longitudeAscendingNode, argumentOfPeriapsis } = params;
        const b = a * Math.sqrt(1 - eccentricity * eccentricity);
        const c = Math.sqrt(a * a - b * b);
        const numPoints = 1000;

        // Generate points for the elliptical orbit
        const curve = new THREE.EllipseCurve(
            -c, 0, a, b, 0, 2 * Math.PI, false, 0
        );

        const points = curve.getPoints(numPoints);
        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        // Create a 3D line from the 2D points
        const material = new THREE.LineBasicMaterial({ color: planetProperties[planetName].color });
        const ellipseObject = new THREE.Line(geometry, material);

        // Apply rotations to the elliptical orbit
        const rotationMatrix = new THREE.Matrix4()
            .makeRotationZ(argumentOfPeriapsis)
            .multiply(new THREE.Matrix4().makeRotationX(inclination))
            .multiply(new THREE.Matrix4().makeRotationZ(longitudeAscendingNode));
        ellipseObject.applyMatrix4(rotationMatrix);

        scene.add(ellipseObject);

        // Create a planet for each orbit
        const planetGeometry = new THREE.SphereGeometry(planetProperties[planetName].size, 32, 32);
        const planetMaterial = new THREE.MeshBasicMaterial({ color: planetProperties[planetName].color });
        const planet = new THREE.Mesh(planetGeometry, planetMaterial);
        scene.add(planet);
        planetObjects[planetName] = planet;
    }

    // Function to solve Kepler's equation (M = E - e*sin(E)) using Newton-Raphson method
    function solveKepler(M, e, tolerance = 1e-6) {
        let E = M;
        let delta;
        do {
            delta = E - e * Math.sin(E) - M;
            E = E - delta / (1 - e * Math.cos(E));
        } while (Math.abs(delta) > tolerance);
        return E;
    }

    // Correct orbital rotation application in updatePlanetPosition
    function updatePlanetPosition(planetName, time) {
        const params = planetsData[planetName];
        const { semiMajorAxis: a, eccentricity, orbitalPeriod, inclination, longitudeAscendingNode, argumentOfPeriapsis } = params;
        const planet = planetObjects[planetName];

        // Calculate Mean Anomaly
        const meanAnomaly = (2 * Math.PI / orbitalPeriod) * time;
        const eccentricAnomaly = solveKepler(meanAnomaly, eccentricity);

        // True Anomaly
        const trueAnomaly = 2 * Math.atan2(
            Math.sqrt(1 + eccentricity) * Math.sin(eccentricAnomaly / 2),
            Math.sqrt(1 - eccentricity) * Math.cos(eccentricAnomaly / 2)
        );

        // Distance from the Sun (r)
        const r = a * (1 - eccentricity * eccentricity) / (1 + eccentricity * Math.cos(trueAnomaly));

        // Position in orbital plane (before rotations)
        const x = r * Math.cos(trueAnomaly);
        const y = r * Math.sin(trueAnomaly);

        const position = new THREE.Vector3(x, y, 0);

        // Apply correct rotation sequence: 
        // 1. Longitude of Ascending Node (rotate around z-axis)
        position.applyAxisAngle(new THREE.Vector3(0, 0, 1), longitudeAscendingNode);
        
        // 2. Inclination (rotate around x-axis)
        position.applyAxisAngle(new THREE.Vector3(1, 0, 0), inclination);
        
        // 3. Argument of Periapsis (rotate around z-axis)
        position.applyAxisAngle(new THREE.Vector3(0, 0, 1), argumentOfPeriapsis);

        // Set the new position of the planet
        planet.position.copy(position);
    }

    // Animation loop
    let time = 0;
    function animate() {
        requestAnimationFrame(animate);
        controls.update();

        // Update positions for all planets
        planetNames.forEach(planetName => {
            updatePlanetPosition(planetName, time * planetsData[planetName].orbitalPeriod / 365);
        });

        // Increment time (1 Earth day per frame)
        time += 1;

        renderer.render(scene, camera);
    }

    animate();

    // Handle window resizing
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
